import {
  ConvenienceRenderer,
  cSharpOptions,
  CSharpRenderer,
  CSharpTargetLanguage,
  systemTextJsonCSharpOptions,
  SystemTextJsonCSharpRenderer,
  Type,
  type LanguageName,
  type OptionValues,
  type RenderContext,
  type RendererOptions,
  type Sourcelike,
} from "quicktype-core";
import { splitDescription } from "./utility.js";
import {
  type PreparedService,
  type PreparedTypeReference,
} from "./generator.js";
import { namingFunction } from "quicktype-core/dist/language/CSharp/utils.js";
import { utf16StringEscape } from "quicktype-core/dist/support/Strings.js";
import { RenderAdapter, type RenderAccessible } from "./render-adapter.js";

// Change some defaults globally
cSharpOptions.features.definition.defaultValue = "attributes-only";
cSharpOptions.framework.definition.defaultValue = "SystemTextJson";
cSharpOptions.namespace.definition.defaultValue = "NexusServices";

export class CSharpLanguageWithNexus extends CSharpTargetLanguage {
  protected override makeRenderer<Lang extends LanguageName = "csharp">(
    renderContext: RenderContext,
    untypedOptionValues: RendererOptions<Lang>,
  ): ConvenienceRenderer {
    const adapter = new CSharpRenderAdapter(
      super.makeRenderer(renderContext, untypedOptionValues),
      untypedOptionValues,
    );

    return adapter.makeRenderer({
      emitSourceStructure(original, givenOutputFilename) {
        original(givenOutputFilename);
        adapter.render.finishFile(adapter.makeFileName());
      },
      emitTypesAndSupport(original) {
        adapter.emitServices();
        original();
      },
      emitUsings(original) {
        adapter.emitUsings();
        original();
      },
      emitDefaultLeadingComments(original) {
        adapter.emitDefaultLeadingComments();
        original();
      },
    });
  }
}

// emitTypesAndSupport is private, omit before adding
type CSharpRenderAccessible = Omit<CSharpRenderer, "emitTypesAndSupport"> &
  RenderAccessible & {
    readonly _csOptions: OptionValues<typeof cSharpOptions>;
    csType(
      t: Type,
      follow?: (t: Type) => Type,
      withIssues?: boolean,
    ): Sourcelike;
    emitBlock(f: () => void): void;
    emitDefaultLeadingComments(): void;
    emitTypesAndSupport(): void;
    emitUsings(): void;
  };

class CSharpRenderAdapter extends RenderAdapter<CSharpRenderAccessible> {
  makeFileName() {
    // If there is a single service, use that, otherwise use the
    // filename sans extensions to build it
    const services = Object.entries(this.schema.services);
    if (services.length == 1) {
      return "I" + namingFunction.nameStyle(services[0][0]) + ".cs";
    }
    return (
      namingFunction.nameStyle(
        this.nexusRendererOptions.firstFilenameSansExtensions,
      ) + ".cs"
    );
  }

  emitDefaultLeadingComments() {
    // If it's System.Text.Json and not using helpers, we need to emit things
    if (
      (this.render as any) instanceof SystemTextJsonCSharpRenderer &&
      !(
        this.render._csOptions as OptionValues<
          typeof systemTextJsonCSharpOptions
        >
      ).features.helpers
    ) {
      this.render.emitLine("// <auto-generated />");
      this.render.emitLine("#pragma warning disable CS8618");
    }
  }

  emitUsings() {
    this.render.emitLine("using NexusRpc;");
  }

  emitServices() {
    for (const [serviceName, serviceSchema] of Object.entries(
      this.schema.services,
    )) {
      this.emitService(serviceName, serviceSchema);
    }
  }

  emitService(serviceName: string, serviceSchema: PreparedService) {
    // TODO(cretz): Support force-set type name here
    // TODO(cretz): Support a gen option to not add the "I"
    // TODO(cretz): Put these I-prefixed names in the forbidden-top-level-names list
    this.render.ensureBlankLine();

    // Doc
    this.render.emitDescription(splitDescription(serviceSchema.description));

    const typeName = this.makeServiceTypeName(
      "I" + namingFunction.nameStyle(serviceName),
    );
    this.render.emitLine(
      "[NexusService",
      // If the sans-I form doesn't match, set the name explicitly
      serviceName == typeName.substring(1)
        ? []
        : ['("', utf16StringEscape(serviceName), '")'],
      "]",
    );

    // Create interface itself
    this.render.emitLine("public interface ", typeName);
    const methodNamesInUse = {};
    this.render.emitBlock(() => {
      this.render.forEachWithBlankLines(
        Object.entries(serviceSchema.operations),
        "interposing",
        (op, opName, pos) => {
          // TODO(cretz): Param and return tags
          this.render.emitDescription(splitDescription(op.description));
          // Convert the opName to C# style
          // TODO(cretz): What about reserved words?
          const methodName = this.makeOperationFunctionName(
            namingFunction.nameStyle(opName),
            methodNamesInUse,
          );
          // Create the attribute
          this.render.emitLine(
            "[NexusOperation",
            // If the method name doesn't match op name, set explicitly
            methodName == opName ? [] : ['("', utf16StringEscape(opName), '")'],
            "]",
          );
          const inType = this.getNexusType(op.input);
          this.render.emitLine(
            this.getNexusType(op.output) ?? "void",
            " ",
            methodName,
            "(",
            inType ? [inType, " input"] : [],
            ");",
          );
        },
      );
    });
  }

  getNexusType(
    reference: PreparedTypeReference | undefined,
  ): Sourcelike | undefined {
    if (!reference) {
      return undefined;
    } else if (reference.kind == "existing") {
      return reference.name;
    } else {
      const type = this.render.topLevels.get(reference.name);
      if (!type) {
        throw new Error(`Unable to find type for ${reference.name}`);
      }
      return this.render.csType(type);
    }
  }
}
